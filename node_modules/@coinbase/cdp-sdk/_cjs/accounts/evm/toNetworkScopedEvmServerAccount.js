"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toNetworkScopedEvmServerAccount = toNetworkScopedEvmServerAccount;
const chains_1 = require("viem/chains");
const chainToNetworkMapper_js_1 = require("./chainToNetworkMapper.js");
const networkCapabilities_js_1 = require("./networkCapabilities.js");
const resolveViemClients_js_1 = require("./resolveViemClients.js");
const transferWithViem_js_1 = require("../../actions/evm/transfer/transferWithViem.js");
/**
 * Creates a Network-scoped Server-managed EvmAccount instance from an existing EvmAccount.
 * Use this to interact with previously deployed EvmAccounts on a specific network.
 *
 * @param {ToNetworkScopedEvmServerAccountOptions} options - Configuration options.
 * @param {EvmServerAccount} options.account - The EvmServerAccount that was previously created.
 * @param {string} options.network - The network to scope the account to.
 * @returns {NetworkScopedEvmServerAccount} A configured NetworkScopedEvmServerAccount instance ready for signing.
 */
async function toNetworkScopedEvmServerAccount(options) {
    const { publicClient, walletClient, chain } = await (0, resolveViemClients_js_1.resolveViemClients)({
        networkOrNodeUrl: options.network,
        account: options.account,
    });
    const shouldUseApiForSends = chain.id === chains_1.base.id ||
        chain.id === chains_1.baseSepolia.id ||
        chain.id === chains_1.mainnet.id ||
        chain.id === chains_1.sepolia.id;
    const account = {
        address: options.account.address,
        network: options.network,
        signMessage: options.account.signMessage,
        sign: options.account.sign,
        signTransaction: options.account.signTransaction,
        signTypedData: options.account.signTypedData,
        name: options.account.name,
        type: "evm-server",
        policies: options.account.policies,
        sendTransaction: async (txOpts) => {
            if (shouldUseApiForSends) {
                return options.account.sendTransaction({
                    ...txOpts,
                    network: (0, chainToNetworkMapper_js_1.mapChainToNetwork)(chain),
                });
            }
            else {
                const hash = await walletClient.sendTransaction(txOpts.transaction);
                return { transactionHash: hash };
            }
        },
        transfer: async (transferArgs) => {
            if (shouldUseApiForSends) {
                return options.account.transfer({
                    ...transferArgs,
                    network: (0, chainToNetworkMapper_js_1.mapChainToNetwork)(chain),
                });
            }
            else {
                return (0, transferWithViem_js_1.transferWithViem)(walletClient, account, transferArgs);
            }
        },
        waitForTransactionReceipt: async (waitOptions) => {
            if ("transactionHash" in waitOptions) {
                return publicClient.waitForTransactionReceipt({
                    hash: waitOptions.transactionHash,
                });
            }
            return publicClient.waitForTransactionReceipt(waitOptions);
        },
    };
    if ((0, networkCapabilities_js_1.isMethodSupportedOnNetwork)("listTokenBalances", options.network)) {
        Object.assign(account, {
            listTokenBalances: async (listTokenBalancesOptions) => {
                return options.account.listTokenBalances({
                    ...listTokenBalancesOptions,
                    network: options.network,
                });
            },
        });
    }
    if ((0, networkCapabilities_js_1.isMethodSupportedOnNetwork)("requestFaucet", options.network)) {
        Object.assign(account, {
            requestFaucet: async (faucetOptions) => {
                return options.account.requestFaucet({
                    ...faucetOptions,
                    network: chain.id === chains_1.baseSepolia.id ? "base-sepolia" : "ethereum-sepolia",
                });
            },
        });
    }
    if ((0, networkCapabilities_js_1.isMethodSupportedOnNetwork)("quoteFund", options.network)) {
        Object.assign(account, {
            quoteFund: async (quoteFundOptions) => {
                return options.account.quoteFund({
                    ...quoteFundOptions,
                });
            },
        });
    }
    if ((0, networkCapabilities_js_1.isMethodSupportedOnNetwork)("fund", options.network)) {
        Object.assign(account, {
            fund: async (fundOptions) => {
                return options.account.fund({
                    ...fundOptions,
                });
            },
            waitForFundOperationReceipt: async (waitOptions) => {
                return options.account.waitForFundOperationReceipt(waitOptions);
            },
        });
    }
    if ((0, networkCapabilities_js_1.isMethodSupportedOnNetwork)("transfer", options.network)) {
        Object.assign(account, {
            transfer: async (transferOptions) => {
                return options.account.transfer(transferOptions);
            },
        });
    }
    if ((0, networkCapabilities_js_1.isMethodSupportedOnNetwork)("quoteSwap", options.network)) {
        Object.assign(account, {
            quoteSwap: async (quoteSwapOptions) => {
                return options.account.quoteSwap(quoteSwapOptions);
            },
        });
    }
    if ((0, networkCapabilities_js_1.isMethodSupportedOnNetwork)("swap", options.network)) {
        Object.assign(account, {
            swap: async (swapOptions) => {
                return options.account.swap(swapOptions);
            },
        });
    }
    return account;
}
//# sourceMappingURL=toNetworkScopedEvmServerAccount.js.map