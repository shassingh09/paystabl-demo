import { base, baseSepolia, mainnet, sepolia } from "viem/chains";
import { mapChainToNetwork } from "./chainToNetworkMapper.js";
import { isMethodSupportedOnNetwork } from "./networkCapabilities.js";
import { resolveViemClients } from "./resolveViemClients.js";
import { transferWithViem } from "../../actions/evm/transfer/transferWithViem.js";
/**
 * Creates a Network-scoped Server-managed EvmAccount instance from an existing EvmAccount.
 * Use this to interact with previously deployed EvmAccounts on a specific network.
 *
 * @param {ToNetworkScopedEvmServerAccountOptions} options - Configuration options.
 * @param {EvmServerAccount} options.account - The EvmServerAccount that was previously created.
 * @param {string} options.network - The network to scope the account to.
 * @returns {NetworkScopedEvmServerAccount} A configured NetworkScopedEvmServerAccount instance ready for signing.
 */
export async function toNetworkScopedEvmServerAccount(options) {
    const { publicClient, walletClient, chain } = await resolveViemClients({
        networkOrNodeUrl: options.network,
        account: options.account,
    });
    const shouldUseApiForSends = chain.id === base.id ||
        chain.id === baseSepolia.id ||
        chain.id === mainnet.id ||
        chain.id === sepolia.id;
    const account = {
        address: options.account.address,
        network: options.network,
        signMessage: options.account.signMessage,
        sign: options.account.sign,
        signTransaction: options.account.signTransaction,
        signTypedData: options.account.signTypedData,
        name: options.account.name,
        type: "evm-server",
        policies: options.account.policies,
        sendTransaction: async (txOpts) => {
            if (shouldUseApiForSends) {
                return options.account.sendTransaction({
                    ...txOpts,
                    network: mapChainToNetwork(chain),
                });
            }
            else {
                const hash = await walletClient.sendTransaction(txOpts.transaction);
                return { transactionHash: hash };
            }
        },
        transfer: async (transferArgs) => {
            if (shouldUseApiForSends) {
                return options.account.transfer({
                    ...transferArgs,
                    network: mapChainToNetwork(chain),
                });
            }
            else {
                return transferWithViem(walletClient, account, transferArgs);
            }
        },
        waitForTransactionReceipt: async (waitOptions) => {
            if ("transactionHash" in waitOptions) {
                return publicClient.waitForTransactionReceipt({
                    hash: waitOptions.transactionHash,
                });
            }
            return publicClient.waitForTransactionReceipt(waitOptions);
        },
    };
    if (isMethodSupportedOnNetwork("listTokenBalances", options.network)) {
        Object.assign(account, {
            listTokenBalances: async (listTokenBalancesOptions) => {
                return options.account.listTokenBalances({
                    ...listTokenBalancesOptions,
                    network: options.network,
                });
            },
        });
    }
    if (isMethodSupportedOnNetwork("requestFaucet", options.network)) {
        Object.assign(account, {
            requestFaucet: async (faucetOptions) => {
                return options.account.requestFaucet({
                    ...faucetOptions,
                    network: chain.id === baseSepolia.id ? "base-sepolia" : "ethereum-sepolia",
                });
            },
        });
    }
    if (isMethodSupportedOnNetwork("quoteFund", options.network)) {
        Object.assign(account, {
            quoteFund: async (quoteFundOptions) => {
                return options.account.quoteFund({
                    ...quoteFundOptions,
                });
            },
        });
    }
    if (isMethodSupportedOnNetwork("fund", options.network)) {
        Object.assign(account, {
            fund: async (fundOptions) => {
                return options.account.fund({
                    ...fundOptions,
                });
            },
            waitForFundOperationReceipt: async (waitOptions) => {
                return options.account.waitForFundOperationReceipt(waitOptions);
            },
        });
    }
    if (isMethodSupportedOnNetwork("transfer", options.network)) {
        Object.assign(account, {
            transfer: async (transferOptions) => {
                return options.account.transfer(transferOptions);
            },
        });
    }
    if (isMethodSupportedOnNetwork("quoteSwap", options.network)) {
        Object.assign(account, {
            quoteSwap: async (quoteSwapOptions) => {
                return options.account.quoteSwap(quoteSwapOptions);
            },
        });
    }
    if (isMethodSupportedOnNetwork("swap", options.network)) {
        Object.assign(account, {
            swap: async (swapOptions) => {
                return options.account.swap(swapOptions);
            },
        });
    }
    return account;
}
//# sourceMappingURL=toNetworkScopedEvmServerAccount.js.map