{"version":3,"sources":["../../src/types/shared/money.ts","../../src/types/shared/network.ts","../../src/types/shared/evm/index.ts","../../src/types/shared/evm/eip3009.ts","../../src/types/shared/evm/wallet.ts","../../src/types/verify/x402Specs.ts","../../src/types/verify/facilitator.ts","../../src/shared/json.ts","../../src/schemes/exact/evm/sign.ts","../../src/schemes/exact/evm/utils/paymentUtils.ts","../../src/schemes/exact/evm/client.ts","../../src/client/createPaymentHeader.ts","../../src/client/preparePaymentHeader.ts","../../src/shared/network.ts","../../src/client/selectPaymentRequirements.ts","../../src/client/signPaymentHeader.ts","../../src/shared/paywall.ts","../../src/shared/base64.ts","../../src/shared/jwt.ts","../../src/shared/middleware.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const moneySchema = z\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\n\nexport type Money = z.input<typeof moneySchema>;\n","import { z } from \"zod\";\n\nexport const NetworkSchema = z.enum([\"base-sepolia\", \"base\"]);\nexport type Network = z.infer<typeof NetworkSchema>;\n\nexport const SupportedEVMNetworks: Network[] = [\"base-sepolia\", \"base\"];\nexport const EvmNetworkToChainId = new Map<Network, number>([\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n]);\n","export * from \"./config\";\nexport * from \"./eip3009\";\nexport * from \"./erc20PermitABI\";\nexport * from \"./wallet\";\n","export const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n};\n\nexport const authorizationPrimaryType = \"TransferWithAuthorization\";\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport type {\n  Chain,\n  Transport,\n  Client,\n  Account,\n  RpcSchema,\n  PublicActions,\n  WalletActions,\n  PublicClient,\n} from \"viem\";\nimport { baseSepolia } from \"viem/chains\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Hex } from \"viem\";\n\n// Create a public client for reading data\nexport type SignerWallet<\n  chain extends Chain = Chain,\n  transport extends Transport = Transport,\n  account extends Account = Account,\n> = Client<\n  transport,\n  chain,\n  account,\n  RpcSchema,\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\n>;\n\nexport type ConnectedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  account extends Account | undefined = undefined,\n> = PublicClient<transport, chain, account>;\n\n/**\n * Creates a public client configured for the Base Sepolia testnet\n *\n * @returns A public client instance connected to Base Sepolia\n */\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\n  return createPublicClient({\n    chain: baseSepolia,\n    transport: http(),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\n *\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\n */\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\n  return createWalletClient({\n    chain: baseSepolia,\n    transport: http(),\n    account: privateKeyToAccount(privateKey),\n  }).extend(publicActions);\n}\n","import { z } from \"zod\";\nimport { NetworkSchema } from \"../shared\";\n// Constants\nconst EvmMaxAtomicUnits = 18;\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]{130}$/;\n// Enums\nexport const schemes = [\"exact\"] as const;\nexport const x402Versions = [1] as const;\nexport const ErrorReasons = [\"insufficient_funds\", \"invalid_scheme\", \"invalid_network\"] as const;\n// Refiners\nconst isInteger = (value: string) => Number.isInteger(Number(value)) && Number(value) >= 0;\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\n\n// x402PaymentRequirements\nexport const PaymentRequirementsSchema = z.object({\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z.string().refine(isInteger),\n  resource: z.string().url(),\n  description: z.string(),\n  mimeType: z.string(),\n  outputSchema: z.record(z.any()).optional(),\n  payTo: z.string().regex(MixedAddressRegex),\n  maxTimeoutSeconds: z.number().int(),\n  asset: z.string().regex(MixedAddressRegex),\n  extra: z.record(z.any()).optional(),\n});\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\n\n// x402ExactEvmPayload\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\n  from: z.string().regex(EvmAddressRegex),\n  to: z.string().regex(EvmAddressRegex),\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z.string().refine(isInteger),\n  validBefore: z.string().refine(isInteger),\n  nonce: z.string().regex(HexEncoded64ByteRegex),\n});\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\n\nexport const ExactEvmPayloadSchema = z.object({\n  signature: z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema,\n});\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\n\n// x402PaymentPayload\nexport const PaymentPayloadSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  payload: ExactEvmPayloadSchema,\n});\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\n};\n\n// x402VerifyResponse\nexport const VerifyResponseSchema = z.object({\n  isValid: z.boolean(),\n  invalidReason: z.enum(ErrorReasons).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n});\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\n\n// x402SettleResponse\nexport const SettleResponseSchema = z.object({\n  success: z.boolean(),\n  errorReason: z.enum(ErrorReasons).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n  transaction: z.string().regex(MixedAddressRegex),\n  network: NetworkSchema,\n});\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\n\n// x402SupportedPaymentKind\nexport const SupportedPaymentKindSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n});\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\n\n// x402SupportedPaymentKindsResponse\nexport const SupportedPaymentKindsResponseSchema = z.object({\n  kinds: z.array(SupportedPaymentKindSchema),\n});\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\n","import { z } from \"zod\";\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\n\nexport const facilitatorRequestSchema = z.object({\n  paymentHeader: z.string(),\n  paymentRequirements: PaymentRequirementsSchema,\n});\n\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\n\n/**\n * Encodes a settlement response into a base64 header string\n *\n * @param response - The settlement response to encode\n * @returns A base64 encoded string containing the settlement response\n */\nexport function settleResponseHeader(response: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(response));\n}\n\n/**\n * Decodes a base64 header string back into a settlement response\n *\n * @param header - The base64 encoded settlement response header\n * @returns The decoded settlement response object\n */\nexport function settleResponseFromHeader(header: string): SettleResponse {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as SettleResponse;\n}\n","/**\n * Converts an object to a JSON-safe format by converting bigint values to strings\n * and recursively processing nested objects and arrays\n *\n * @param data - The object to convert to JSON-safe format\n * @returns A new object with all bigint values converted to strings\n */\nexport function toJsonSafe<T extends object>(data: T): object {\n  if (typeof data !== \"object\") {\n    throw new Error(\"Data is not an object\");\n  }\n\n  /**\n   * Recursively converts values to JSON-safe format\n   *\n   * @param value - The value to convert\n   * @returns The converted value with bigints as strings\n   */\n  function convert(value: unknown): unknown {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(convert);\n    }\n\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n\n  return convert(data) as object;\n}\n","import { Address, Chain, Hex, toHex, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport { getVersion } from \"../../../shared/evm\";\nimport { authorizationTypes, config, SignerWallet } from \"../../../types/shared/evm\";\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\nimport { getRandomValues } from \"crypto\";\n\n/**\n * Signs an EIP-3009 authorization for USDC transfer\n *\n * @param walletClient - The wallet client that will sign the authorization\n * @param params - The authorization parameters containing transfer details\n * @param params.from - The address tokens will be transferred from\n * @param params.to - The address tokens will be transferred to\n * @param params.value - The amount of USDC tokens to transfer (in base units)\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\n * @param params.validBefore - Unix timestamp before which the authorization is valid\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\n * @param paymentRequirements - The payment requirements containing asset and network information\n * @param paymentRequirements.asset - The address of the USDC contract\n * @param paymentRequirements.network - The network where the USDC contract exists\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\n * @returns The signature for the authorization\n */\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\n  walletClient: SignerWallet<chain, transport>,\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\n  { asset, network, extra }: PaymentRequirements,\n): Promise<{ signature: Hex }> {\n  const chainId = getNetworkId(network);\n  const name = extra?.name ?? config[chainId].usdcName;\n  const version = extra?.version ?? (await getVersion(walletClient));\n\n  const data = {\n    account: walletClient.account!,\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: asset as Address,\n    },\n    primaryType: \"TransferWithAuthorization\" as const,\n    message: {\n      from,\n      to,\n      value,\n      validAfter,\n      validBefore,\n      nonce: nonce,\n    },\n  };\n\n  const signature = await walletClient.signTypedData(data);\n\n  return {\n    signature,\n  };\n}\n\n/**\n * Generates a random 32-byte nonce for use in authorization signatures\n *\n * @returns A random 32-byte nonce as a hex string\n */\nexport function createNonce(): Hex {\n  return toHex(getRandomValues(new Uint8Array(32)));\n}\n","import { safeBase64Encode, safeBase64Decode } from \"../../../../shared\";\nimport { PaymentPayload, PaymentPayloadSchema } from \"../../../../types/verify\";\n\n/**\n * Encodes a payment payload into a base64 string, ensuring bigint values are properly stringified\n *\n * @param payment - The payment payload to encode\n * @returns A base64 encoded string representation of the payment payload\n */\nexport function encodePayment(payment: PaymentPayload): string {\n  const safe = {\n    ...payment,\n    payload: {\n      ...payment.payload,\n      authorization: Object.fromEntries(\n        Object.entries(payment.payload.authorization).map(([key, value]) => [\n          key,\n          typeof value === \"bigint\" ? (value as bigint).toString() : value,\n        ]),\n      ),\n    },\n  };\n  return safeBase64Encode(JSON.stringify(safe));\n}\n\n/**\n * Decodes a base64 encoded payment string back into a PaymentPayload object\n *\n * @param payment - The base64 encoded payment string to decode\n * @returns The decoded and validated PaymentPayload object\n */\nexport function decodePayment(payment: string): PaymentPayload {\n  const decoded = safeBase64Decode(payment);\n  const parsed = JSON.parse(decoded);\n\n  const obj = {\n    ...parsed,\n    payload: {\n      signature: parsed.payload.signature,\n      authorization: {\n        ...parsed.payload.authorization,\n        value: parsed.payload.authorization.value,\n        validAfter: parsed.payload.authorization.validAfter,\n        validBefore: parsed.payload.authorization.validBefore,\n      },\n    },\n  };\n\n  const validated = PaymentPayloadSchema.parse(obj);\n  return validated;\n}\n","import { Address, Chain, Transport } from \"viem\";\nimport { SignerWallet } from \"../../../types/shared/evm\";\nimport { PaymentPayload, PaymentRequirements, UnsignedPaymentPayload } from \"../../../types/verify\";\nimport { createNonce, signAuthorization } from \"./sign\";\nimport { encodePayment } from \"./utils/paymentUtils\";\n\n/**\n * Prepares an unsigned payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload containing authorization details\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  const nonce = createNonce();\n\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1000) - 5, // 1 block (2s) before to account for block timestamping\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1000 + paymentRequirements.maxTimeoutSeconds),\n  ).toString();\n\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: undefined,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo as Address,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce,\n      },\n    },\n  };\n}\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the signed payment payload\n */\nexport async function signPaymentHeader<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport>,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<PaymentPayload> {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements,\n  );\n\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature,\n    },\n  };\n}\n\n/**\n * Creates a complete payment payload by preparing and signing a payment header.\n *\n * @param client - The signer wallet instance used to create and sign the payment\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the complete signed payment payload\n */\nexport async function createPayment<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport>,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const from = client!.account!.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n","import { createPaymentHeader as createPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { SignerWallet } from \"../types/shared/evm\";\nimport { PaymentRequirements } from \"../types/verify\";\n\n/**\n * Creates a payment header based on the provided client and payment requirements.\n * \n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the created payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    return await createPaymentHeaderExactEVM(client, x402Version, paymentRequirements);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}","import { Address } from \"viem\";\nimport { preparePaymentHeader as preparePaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Prepares a payment header with the given sender address and payment requirements.\n * \n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload that can be used to create a payment header\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    return preparePaymentHeaderExactEVM(from, x402Version, paymentRequirements);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}","import { EvmNetworkToChainId, Network } from \"../types/shared\";\n\n/**\n * Converts a network name to its corresponding chain ID\n *\n * @param network - The network name to convert to a chain ID\n * @returns The chain ID for the specified network\n * @throws Error if the network is not supported\n */\nexport function getNetworkId(network: Network): number {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network)!;\n  }\n  // TODO: Solana\n  throw new Error(`Unsupported network: ${network}`);\n}\n","import { PaymentRequirements } from \"../types\";\nimport { getUsdcAddressForChain } from \"../shared/evm\";\nimport { getNetworkId } from \"../shared/network\";\n\n/**\n * Default selector for payment requirements.\n * Default behavior is to select the first payment requirement that has a USDC asset.\n * If no USDC payment requirement is found, the first payment requirement is selected.\n * \n * @param paymentRequirements - The payment requirements to select from.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport function selectPaymentRequirements(paymentRequirements: PaymentRequirements[]): PaymentRequirements {\n  const usdcPaymentRequirement = paymentRequirements.find(requirement => requirement.scheme === \"exact\" && requirement.asset === getUsdcAddressForChain(getNetworkId(requirement.network)));\n  if (usdcPaymentRequirement) {\n    return usdcPaymentRequirement;\n  }\n  return paymentRequirements[0];\n}\n\n/**\n * Selector for payment requirements.\n * \n * @param paymentRequirements - The payment requirements to select from.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport type PaymentRequirementsSelector = (paymentRequirements: PaymentRequirements[]) => PaymentRequirements;\n","import { signPaymentHeader as signPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { encodePayment } from \"../schemes/exact/evm/utils/paymentUtils\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { SignerWallet } from \"../types/shared/evm\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n * \n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the encoded signed payment header string\n */\nexport async function signPaymentHeader(\n  client: SignerWallet,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<string> {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    const signedPaymentHeader = await signPaymentHeaderExactEVM(client, paymentRequirements, unsignedPaymentHeader);\n    return encodePayment(signedPaymentHeader);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}","import { selectPaymentRequirements } from \"../client\";\nimport { PaymentRequirements } from \"../types/verify\";\n\ninterface PaywallOptions {\n  amount: number;\n  paymentRequirements: PaymentRequirements[];\n  currentUrl: string;\n  testnet: boolean;\n}\n\n/**\n * Generates an HTML paywall page that allows users to pay for content access\n *\n * @param options - The options for generating the paywall\n * @param options.amount - The amount to be paid in USD\n * @param options.paymentRequirements - The payment requirements for the content\n * @param options.currentUrl - The URL of the content being accessed\n * @param options.testnet - Whether to use testnet or mainnet\n * @returns An HTML string containing the paywall page\n */\nexport function getPaywallHtml({\n  amount,\n  testnet,\n  paymentRequirements,\n  currentUrl,\n}: PaywallOptions): string {\n  const selectedPaymentRequirements = selectPaymentRequirements(paymentRequirements);\n  return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>Payment Required - $${amount}</title>\n<link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" />\n\n<style>\n  /* Reset */\n  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\n  body { line-height: 1.5; -webkit-font-smoothing: antialiased; }\n  img, picture, video, canvas, svg { display: block; max-width: 100%; }\n  input, button, textarea, select { font: inherit; }\n  p, h1, h2, h3, h4, h5, h6 { overflow-wrap: break-word; }\n\n  /* Custom Styles */\n  body {\n    min-height: 100vh;\n    background-color: #f9fafb;\n    font-family: system-ui, -apple-system, sans-serif;\n  }\n\n  .container {\n    max-width: 32rem;\n    margin: 4rem auto;\n    padding: 1.5rem;\n    background-color: white;\n    border-radius: 0.75rem;\n    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  }\n\n  .header {\n    text-align: center;\n    margin-bottom: 2rem;\n  }\n\n  .title {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: #111827;\n    margin-bottom: 0.5rem;\n  }\n\n  .subtitle {\n    color: #4b5563;\n    margin-bottom: 1rem;\n  }\n\n  .instructions {\n    font-size: 0.9rem;\n    color: #4b5563;\n    font-style: italic;\n  }\n\n  .content {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n  }\n\n  .button {\n    width: 100%;\n    padding: 0.5rem 1rem;\n    border-radius: 0.5rem;\n    font-weight: 600;\n    border: none;\n    cursor: pointer;\n    transition: background-color 150ms;\n  }\n\n  .button:focus {\n    outline: none;\n    ring: 2px solid rgba(59, 130, 246, 0.5);\n  }\n\n  .button-blue {\n    background-color: #2563eb;\n    color: white;\n  }\n\n  .button-blue:hover {\n    background-color: #1d4ed8;\n  }\n\n  .button-green {\n    background-color: #059669;\n    color: white;\n  }\n\n  .button-green:hover {\n    background-color: #047857;\n  }\n\n  .payment-details {\n    padding: 1rem;\n    background-color: #f9fafb;\n    border-radius: 0.5rem;\n  }\n\n  .payment-row {\n    display: flex;\n    justify-content: space-between;\n    font-size: 0.875rem;\n    margin-bottom: 0.5rem;\n  }\n\n  .payment-row:last-child {\n    margin-bottom: 0;\n  }\n\n  .payment-label {\n    color: #4b5563;\n  }\n\n  .payment-value {\n    font-weight: 500;\n  }\n\n  .hidden {\n    display: none;\n  }\n\n  .status {\n    text-align: center;\n    font-size: 0.875rem;\n  }\n</style>\n\n<!-- Inject server-side variables -->\n<script>\n  try {\n    // Initialize x402 namespace\n    window.x402 = {\n      paymentRequirements: ${JSON.stringify(selectedPaymentRequirements)},\n      isTestnet: ${testnet},\n      currentUrl: \"${currentUrl}\",\n      state: {\n        publicClient: null,\n        chain: null,\n        walletClient: null\n      },\n      config: {\n        chainConfig: {\n          \"84532\": {\n            usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n            usdcName: \"USDC\",\n          },\n          \"8453\": {\n            usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n            usdcName: \"USDC\",\n          }\n        },\n        networkToChainId: {\n          \"base-sepolia\": 84532,\n          \"base\": 8453\n        }\n      }\n    };\n    console.log('Payment requirements initialized:', window.x402.paymentRequirements);\n  } catch (error) {\n    console.error('Error initializing x402:', error.message);\n  };\n</script>\n\n<!-- x402 -->\n<script type=\"module\">\n  import {\n    createWalletClient,\n    createPublicClient,\n    http,\n    custom,\n    toHex,\n  } from 'https://esm.sh/viem'\n\n  import {\n    createConfig,\n    connect,\n    disconnect,\n    signMessage,\n    getBalance,\n  } from 'https://esm.sh/@wagmi/core'\n\n  import { injected, coinbaseWallet } from 'https://esm.sh/@wagmi/connectors'\n\n  import { base, baseSepolia } from 'https://esm.sh/viem/chains'\n\n  const authorizationTypes = {\n    EIP712Domain: [\n      { name: \"name\", type: \"string\" },\n      { name: \"version\", type: \"string\" },\n      { name: \"chainId\", type: \"uint256\" },\n      { name: \"verifyingContract\", type: \"address\" },\n    ],\n    TransferWithAuthorization: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n    ],\n  };\n\n  // USDC ABI for version function\n  const usdcABI = [{\n    \"inputs\": [],\n    \"name\": \"version\",\n    \"outputs\": [{\"internalType\": \"string\",\"name\": \"\",\"type\": \"string\"}],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }];\n\n  window.x402.utils = {\n    createNonce: () => {\n      return toHex(crypto.getRandomValues(new Uint8Array(32)));\n    },\n    safeBase64Encode: (data) => {\n      if (typeof window !== \"undefined\") {\n        return window.btoa(data);\n      }\n      return Buffer.from(data).toString(\"base64\");\n    },\n    getUsdcAddressForChain: (chainId) => {\n      return window.x402.config.chainConfig[chainId.toString()].usdcAddress;\n    },\n    getNetworkId: (network) => {\n      const chainId = window.x402.config.networkToChainId[network];\n      if (!chainId) {\n        throw new Error('Unsupported network: ' + network);\n      }\n      return chainId;\n    },\n    getVersion: async (publicClient, usdcAddress) => {\n      const version = await publicClient.readContract({\n        address: usdcAddress,\n        abi: usdcABI,\n        functionName: \"version\"\n      });\n      return version;\n    },\n    encodePayment: (payment) => {\n      const safe = {\n        ...payment,\n        payload: {\n          ...payment.payload,\n          authorization: Object.fromEntries(\n            Object.entries(payment.payload.authorization).map(([key, value]) => [\n              key,\n              typeof value === \"bigint\" ? value.toString() : value,\n            ])\n          ),\n        },\n      };\n      return window.x402.utils.safeBase64Encode(JSON.stringify(safe));\n    },\n    createPaymentHeader: async (client, publicClient) => {\n      const payment = await window.x402.utils.createPayment(client, publicClient);\n      return window.x402.utils.encodePayment(payment);\n    },\n  }\n\n  window.x402.utils.signAuthorization = async (walletClient, authorizationParameters, paymentRequirements, publicClient) => {\n    const chainId = window.x402.utils.getNetworkId(paymentRequirements.network);\n    const name = paymentRequirements.extra?.name ?? window.x402.config.chainConfig[chainId].usdcName;\n    const erc20Address = paymentRequirements.asset;\n    const version = paymentRequirements.extra?.version ?? await window.x402.utils.getVersion(publicClient, erc20Address);\n    const { from, to, value, validAfter, validBefore, nonce } = authorizationParameters;\n    const data = {\n      account: walletClient.account,\n      types: authorizationTypes,\n      domain: {\n        name,\n        version,\n        chainId,\n        verifyingContract: erc20Address,\n      },\n      primaryType: \"TransferWithAuthorization\",\n      message: {\n        from,\n        to,\n        value,\n        validAfter,\n        validBefore,\n        nonce,\n      },\n    };\n\n    const signature = await walletClient.signTypedData(data);\n\n    return {\n      signature,\n    };\n  }\n\n  window.x402.utils.createPayment = async (client, publicClient) => {\n    if (!window.x402.paymentRequirements) {\n      throw new Error('Payment requirements not initialized');\n    }\n\n    const nonce = window.x402.utils.createNonce();\n    const version = await window.x402.utils.getVersion(publicClient, window.x402.utils.getUsdcAddressForChain(window.x402.utils.getNetworkId(window.x402.paymentRequirements.network)));\n    const from = client.account.address;\n\n    const validAfter = BigInt(\n      Math.floor(Date.now() / 1000) - 5 // 1 block (2s) before to account for block timestamping\n    );\n    const validBefore = BigInt(\n      Math.floor(Date.now() / 1000 + window.x402.paymentRequirements.maxTimeoutSeconds)\n    );\n\n    const { signature } = await window.x402.utils.signAuthorization(\n      client,\n      {\n        from,\n        to: window.x402.paymentRequirements.payTo,\n        value: window.x402.paymentRequirements.maxAmountRequired,\n        validAfter,\n        validBefore,\n        nonce,\n        version,\n      },\n      window.x402.paymentRequirements,\n      publicClient\n    );\n\n    return {\n      x402Version: 1,\n      scheme: window.x402.paymentRequirements.scheme,\n      network: window.x402.paymentRequirements.network,\n      payload: {\n        signature,\n        authorization: {\n          from,\n          to: window.x402.paymentRequirements.payTo,\n          value: window.x402.paymentRequirements.maxAmountRequired,\n          validAfter,\n          validBefore,\n          nonce,\n        },\n      },\n    };\n  }\n\n\n  async function initializeApp() {\n    const x402 = window.x402;\n    const wagmiConfig = createConfig({\n      chains: [base, baseSepolia],\n      connectors: [\n        coinbaseWallet({ appName: 'Create Wagmi' }),\n        injected(),\n      ],\n      transports: {\n        [base.id]: http(),\n        [baseSepolia.id]: http(),\n      },\n    });\n\n    // DOM Elements\n    const connectWalletBtn = document.getElementById('connect-wallet');\n    const paymentSection = document.getElementById('payment-section');\n    const payButton = document.getElementById('pay-button');\n    const statusDiv = document.getElementById('status');\n\n    if (!connectWalletBtn || !paymentSection || !payButton || !statusDiv) {\n      // console.error('Required DOM elements not found');\n      return;\n    }\n\n    let walletClient = null;\n    const chain = x402.isTestnet ? baseSepolia : base;\n\n    const publicClient = createPublicClient({\n      chain,\n      transport: custom(window.ethereum),\n    });\n\n    // Connect wallet handler\n    connectWalletBtn.addEventListener('click', async () => {\n      // If wallet is already connected, disconnect it\n      if (walletClient) {\n        try {\n          await disconnect(wagmiConfig);\n          walletClient = null;\n          connectWalletBtn.textContent = 'Connect Wallet';\n          paymentSection.classList.add('hidden');\n          statusDiv.textContent = 'Wallet disconnected';\n          return;\n        } catch (error) {\n          statusDiv.textContent = 'Failed to disconnect wallet';\n          return;\n        }\n      }\n\n      try {\n        statusDiv.textContent = 'Connecting wallet...';\n\n        const result = await connect(wagmiConfig, {\n          connector: injected(),\n          chainId: chain.id,\n        });\n        if (!result.accounts?.[0]) {\n          throw new Error('Please select an account in your wallet');\n        }\n        walletClient = createWalletClient({\n          account: result.accounts[0],\n          chain,\n          transport: custom(window.ethereum)\n        });\n\n        const address = result.accounts[0]\n\n        connectWalletBtn.textContent = \\`\\${address.slice(0, 6)}...\\${address.slice(-4)}\\`;\n        paymentSection.classList.remove('hidden');\n        statusDiv.textContent =\n          'Wallet connected! You can now proceed with payment.';\n      } catch (error) {\n        console.error('Connection error:', error);\n        statusDiv.textContent =\n          error instanceof Error ? error.message : 'Failed to connect wallet';\n        // Reset UI state\n        connectWalletBtn.textContent = 'Connect Wallet';\n        paymentSection.classList.add('hidden');\n      }\n    });\n\n  // Payment handler\n  payButton.addEventListener('click', async () => {\n    if (!walletClient) {\n      statusDiv.textContent = 'Please connect your wallet first';\n      return;\n    }\n\n    try {\n      const usdcAddress = window.x402.config.chainConfig[chain.id].usdcAddress;\n      try {\n        statusDiv.textContent = 'Checking USDC balance...';\n        const balance = await publicClient.readContract({\n          address: usdcAddress,\n          abi: [{\n            inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n            name: \"balanceOf\",\n            outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\"\n          }],\n          functionName: \"balanceOf\",\n          args: [walletClient.account.address]\n        });\n\n        if (balance === 0n) {\n          statusDiv.textContent = \\`Your USDC balance is 0. Please make sure you have USDC tokens on ${testnet ? \"Base Sepolia\" : \"Base\"\n    }.\\`;\n          return;\n        }\n\n        statusDiv.textContent = 'Creating payment signature...';\n\n        const paymentHeader = await x402.utils.createPaymentHeader(walletClient, publicClient);\n\n        statusDiv.textContent = 'Requesting content with payment...';\n\n        const response = await fetch(x402.currentUrl, {\n          headers: {\n            'X-PAYMENT': paymentHeader,\n            'Access-Control-Expose-Headers': 'X-PAYMENT-RESPONSE',\n          },\n        });\n\n        if (response.ok) {\n          const contentType = response.headers.get('content-type');\n          if (contentType && contentType.includes('text/html')) {\n            document.documentElement.innerHTML = await response.text();\n          } else {\n            const blob = await response.blob();\n            const url = window.URL.createObjectURL(blob);\n            window.location.href = url;\n          }\n        } else {\n          throw new Error('Payment failed: ' + response.statusText);\n        }\n      } catch (error) {\n        statusDiv.textContent = error instanceof Error ? error.message : 'Failed to check USDC balance';\n      }\n    } catch (error) {\n      statusDiv.textContent = error instanceof Error ? error.message : 'Payment failed';\n    }\n  });\n}\n\nwindow.addEventListener('load', initializeApp);\n</script>\n</head>\n\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1 class=\"title\">Payment Required</h1>\n      <p class=\"subtitle\">${selectedPaymentRequirements.description}. To access this content, please pay $${amount} ${testnet ? \"Base Sepolia\" : \"Base\"} USDC.</p>\n      <p class=\"instructions\">Need Base Sepolia USDC? <a href=\"https://faucet.circle.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Get some here.</a></p>\n    </div>\n\n    <div class=\"content\">\n      <div id=\"connect-section\">\n        <button id=\"connect-wallet\" class=\"button button-blue\">\n            Connect Wallet\n        </button>\n      </div>\n\n      <div id=\"payment-section\" class=\"hidden\">\n        <div class=\"payment-details\">\n          <div class=\"payment-row\">\n            <span class=\"payment-label\">Amount:</span>\n            <span class=\"payment-value\">$${amount} USDC</span>\n          </div>\n          <div class=\"payment-row\">\n            <span class=\"payment-label\">Network:</span>\n            <span class=\"payment-value\">${testnet ? \"Base Sepolia\" : \"Base\"}</span>\n          </div>\n        </div>\n\n        <button id=\"pay-button\" class=\"button button-green\">\n            Pay Now\n        </button>\n      </div>\n      <div id=\"status\" class=\"status\"></div>\n    </div>\n  </div>\n</body>\n</html>`;\n}\n","/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n","import { generateJwt } from \"@coinbase/cdp-sdk/auth\";\n\n/**\n * Creates an authorization header for a request to the Coinbase API.\n *\n * @param apiKeyId - The api key ID\n * @param apiKeySecret - The api key secret\n * @param requestHost - The host for the request (e.g. 'https://x402.org/facilitator')\n * @param requestPath - The path for the request (e.g. '/verify')\n * @returns The authorization header string\n */\nexport async function createAuthHeader(\n  apiKeyId: string,\n  apiKeySecret: string,\n  requestHost: string,\n  requestPath: string,\n) {\n  const jwt = await generateJwt({\n    apiKeyId,\n    apiKeySecret,\n    requestMethod: \"POST\",\n    requestHost,\n    requestPath,\n  });\n  return `Bearer ${jwt}`;\n}\n","import { moneySchema, Network, Price, RouteConfig, RoutePattern, ERC20TokenAmount } from \"../types\";\nimport { RoutesConfig } from \"../types\";\nimport { getUsdcAddressForChain } from \"./evm\";\nimport { getNetworkId } from \"./network\";\n\n/**\n * Computes the route patterns for the given routes config\n *\n * @param routes - The routes config to compute the patterns for\n * @returns The route patterns\n */\nexport function computeRoutePatterns(routes: RoutesConfig): RoutePattern[] {\n  const normalizedRoutes = Object.fromEntries(\n    Object.entries(routes).map(([pattern, value]) => [\n      pattern,\n      typeof value === \"string\" || typeof value === \"number\"\n        ? ({ price: value, network: \"base-sepolia\" } as RouteConfig)\n        : (value as RouteConfig),\n    ]),\n  );\n\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\n    // Split pattern into verb and path, defaulting to \"*\" for verb if not specified\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    if (!path) {\n      throw new Error(`Invalid route pattern: ${pattern}`);\n    }\n    return {\n      verb: verb.toUpperCase(),\n      pattern: new RegExp(\n        `^${path\n          .replace(/\\*/g, \".*?\") // Make wildcard non-greedy and optional\n          .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\")\n          .replace(/\\//g, \"\\\\/\")}$`,\n      ),\n      config: routeConfig,\n    };\n  });\n}\n\n/**\n * Finds the matching route pattern for the given path and method\n *\n * @param routePatterns - The route patterns to search through\n * @param path - The path to match against\n * @param method - The HTTP method to match against\n * @returns The matching route pattern or undefined if no match is found\n */\nexport function findMatchingRoute(\n  routePatterns: RoutePattern[],\n  path: string,\n  method: string,\n): RoutePattern | undefined {\n  // Find matching route pattern\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\n    const matchesPath = pattern.test(path);\n    const matchesVerb = verb === \"*\" || verb === method.toUpperCase();\n    return matchesPath && matchesVerb;\n  });\n\n  if (matchingRoutes.length === 0) {\n    return undefined;\n  }\n\n  // Use the most specific route (longest path pattern)\n  const matchingRoute = matchingRoutes.reduce((a, b) =>\n    b.pattern.source.length > a.pattern.source.length ? b : a,\n  );\n\n  return matchingRoute;\n}\n\n/**\n * Gets the default asset (USDC) for the given network\n *\n * @param network - The network to get the default asset for\n * @returns The default asset\n */\nexport function getDefaultAsset(network: Network) {\n  return {\n    address: getUsdcAddressForChain(getNetworkId(network)),\n    decimals: 6,\n    eip712: {\n      name: network === \"base\" ? \"USD Coin\" : \"USDC\",\n      version: \"2\",\n    },\n  };\n}\n\n/**\n * Parses the amount from the given price\n *\n * @param price - The price to parse\n * @param network - The network to get the default asset for\n * @returns The parsed amount or an error message\n */\nexport function processPriceToAtomicAmount(\n  price: Price,\n  network: Network,\n): { maxAmountRequired: string; asset: ERC20TokenAmount[\"asset\"] } | { error: string } {\n  // Handle USDC amount (string) or token amount (ERC20TokenAmount)\n  let maxAmountRequired: string;\n  let asset: ERC20TokenAmount[\"asset\"];\n\n  if (typeof price === \"string\" || typeof price === \"number\") {\n    // USDC amount in dollars\n    const parsedAmount = moneySchema.safeParse(price);\n    if (!parsedAmount.success) {\n      return {\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`,\n      };\n    }\n    const parsedUsdAmount = parsedAmount.data;\n    asset = getDefaultAsset(network);\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\n  } else {\n    // Token amount in atomic units\n    maxAmountRequired = price.amount;\n    asset = price.asset;\n  }\n\n  return {\n    maxAmountRequired,\n    asset,\n  };\n}\n"],"mappings":"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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAiIN,KAAK,UAAU,2BAA2B,CAAC;AAAA,mBACrD,OAAO;AAAA,qBACL,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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","names":["z","z","z","z","createPaymentHeader","preparePaymentHeader","signPaymentHeader","z"]}