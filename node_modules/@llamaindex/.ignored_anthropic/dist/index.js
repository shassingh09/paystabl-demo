import { LLMAgentWorker, LLMAgent } from '@llamaindex/core/agent';
import { Settings } from '@llamaindex/core/global';
import { Anthropic as Anthropic$1 } from '@anthropic-ai/sdk';
import { wrapEventCaller, wrapLLMEvent } from '@llamaindex/core/decorator';
import { ToolCallLLM } from '@llamaindex/core/llms';
import { extractText } from '@llamaindex/core/utils';
import { getEnv } from '@llamaindex/env';
import { isDeepEqual } from 'remeda';

function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _initProto;
class AnthropicSession {
    constructor(options = {}){
        if (!options.apiKey) {
            options.apiKey = getEnv("ANTHROPIC_API_KEY");
        }
        if (!options.apiKey) {
            throw new Error("Set Anthropic Key in ANTHROPIC_API_KEY env variable");
        }
        this.anthropic = new Anthropic$1(options);
    }
}
// I'm not 100% sure this is necessary vs. just starting a new session
// every time we make a call. They say they try to reuse connections
// so in theory this is more efficient, but we should test it in the future.
const defaultAnthropicSession = [];
/**
 * Get a session for the Anthropic API. If one already exists with the same options,
 * it will be returned. Otherwise, a new session will be created.
 * @param options
 * @returns
 */ function getAnthropicSession(options = {}) {
    let session = defaultAnthropicSession.find((session)=>{
        return isDeepEqual(session.options, options);
    })?.session;
    if (!session) {
        session = new AnthropicSession(options);
        defaultAnthropicSession.push({
            session,
            options
        });
    }
    return session;
}
const ALL_AVAILABLE_ANTHROPIC_LEGACY_MODELS = {
    "claude-2.1": {
        contextWindow: 200000
    },
    "claude-2.0": {
        contextWindow: 100000
    },
    "claude-instant-1.2": {
        contextWindow: 100000
    }
};
const ALL_AVAILABLE_V3_MODELS = {
    "claude-3-opus": {
        contextWindow: 200000
    },
    "claude-3-opus-latest": {
        contextWindow: 200000
    },
    "claude-3-opus-20240229": {
        contextWindow: 200000
    },
    "claude-3-sonnet": {
        contextWindow: 200000
    },
    "claude-3-sonnet-20240229": {
        contextWindow: 200000
    },
    "claude-3-haiku": {
        contextWindow: 200000
    },
    "claude-3-haiku-20240307": {
        contextWindow: 200000
    }
};
const ALL_AVAILABLE_V3_5_MODELS = {
    "claude-3-5-sonnet": {
        contextWindow: 200000
    },
    "claude-3-5-sonnet-20241022": {
        contextWindow: 200000
    },
    "claude-3-5-sonnet-20240620": {
        contextWindow: 200000
    },
    "claude-3-5-sonnet-latest": {
        contextWindow: 200000
    },
    "claude-3-5-haiku": {
        contextWindow: 200000
    },
    "claude-3-5-haiku-latest": {
        contextWindow: 200000
    },
    "claude-3-5-haiku-20241022": {
        contextWindow: 200000
    }
};
const ALL_AVAILABLE_V3_7_MODELS = {
    "claude-3-7-sonnet": {
        contextWindow: 200000
    },
    "claude-3-7-sonnet-20250219": {
        contextWindow: 200000
    },
    "claude-3-7-sonnet-latest": {
        contextWindow: 200000
    }
};
const ALL_AVAILABLE_ANTHROPIC_MODELS = {
    ...ALL_AVAILABLE_ANTHROPIC_LEGACY_MODELS,
    ...ALL_AVAILABLE_V3_MODELS,
    ...ALL_AVAILABLE_V3_5_MODELS,
    ...ALL_AVAILABLE_V3_7_MODELS
};
const AVAILABLE_ANTHROPIC_MODELS_WITHOUT_DATE = {
    "claude-3-opus": "claude-3-opus-20240229",
    "claude-3-sonnet": "claude-3-sonnet-20240229",
    "claude-3-haiku": "claude-3-haiku-20240307",
    "claude-3-5-sonnet": "claude-3-5-sonnet-20240620",
    "claude-3-7-sonnet": "claude-3-7-sonnet-20250219"
};
class Anthropic extends ToolCallLLM {
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                [
                    wrapEventCaller,
                    wrapLLMEvent
                ],
                2,
                "chat"
            ],
            [
                wrapEventCaller,
                2,
                "streamChat"
            ]
        ], []));
    }
    constructor(init){
        super(), this.getModelName = (_initProto(this), (model)=>{
            if (Object.keys(AVAILABLE_ANTHROPIC_MODELS_WITHOUT_DATE).includes(model)) {
                return AVAILABLE_ANTHROPIC_MODELS_WITHOUT_DATE[model];
            }
            return model;
        }), this.parseToolInput = (input)=>{
            if (typeof input === "object" && !Array.isArray(input)) return input;
            if (typeof input === "string") {
                const parsed = JSON.parse(input);
                if (typeof parsed === "object" && !Array.isArray(parsed)) return parsed;
            }
            console.error("Invalid tool input:", input);
            throw new Error("Tool input must be a dictionary");
        };
        this.model = init?.model ?? "claude-3-opus";
        this.temperature = init?.temperature ?? 1; // default in anthropic is 1
        this.topP = init?.topP;
        this.maxTokens = init?.maxTokens ?? undefined;
        this.apiKey = init?.apiKey ?? undefined;
        this.maxRetries = init?.maxRetries ?? 10;
        this.timeout = init?.timeout ?? 60 * 1000; // Default is 60 seconds
        this.additionalChatOptions = init?.additionalChatOptions;
        this.session = init?.session ?? getAnthropicSession({
            apiKey: this.apiKey,
            maxRetries: this.maxRetries,
            timeout: this.timeout
        });
    }
    get supportToolCall() {
        return this.model.startsWith("claude-3");
    }
    get metadata() {
        return {
            model: this.model,
            temperature: this.temperature,
            topP: this.topP ?? 0,
            maxTokens: this.maxTokens,
            contextWindow: this.model in ALL_AVAILABLE_ANTHROPIC_MODELS ? ALL_AVAILABLE_ANTHROPIC_MODELS[this.model].contextWindow : 200000,
            tokenizer: undefined,
            structuredOutput: false
        };
    }
    formatMessages(messages) {
        const formattedMessages = messages.flatMap((message)=>{
            const options = message.options ?? {};
            if (message.role === "system") {
                // Skip system messages
                return [];
            }
            const content = [];
            if (options?.thinking) {
                if (options.thinking_signature == null) {
                    throw new Error("`thinking_signature` is required if `thinking` is provided");
                }
                content.push({
                    type: "thinking",
                    thinking: options.thinking,
                    signature: options.thinking_signature
                });
                const text = extractText(message.content);
                if (text && text.trim().length > 0) {
                    // don't add empty text blocks
                    content.push({
                        type: "text",
                        text: text
                    });
                }
                if (!("toolCall" in options)) {
                    return {
                        role: "assistant",
                        content
                    };
                }
            }
            if ("toolCall" in options) {
                if (content.length === 0 || !content.some((c)=>c.type === "text")) {
                    const text = extractText(message.content);
                    if (text && text.trim().length > 0) {
                        // don't add empty text blocks
                        content.push({
                            type: "text",
                            text: text
                        });
                    }
                }
                content.push(...options.toolCall.map((tool)=>({
                        type: "tool_use",
                        id: tool.id,
                        name: tool.name,
                        input: this.parseToolInput(tool.input)
                    })));
                return {
                    role: "assistant",
                    content
                };
            }
            // Handle tool results
            if ("toolResult" in options) {
                const formattedMessage = {
                    role: "user",
                    content: [
                        {
                            type: "tool_result",
                            tool_use_id: options.toolResult.id,
                            content: extractText(message.content)
                        }
                    ]
                };
                return formattedMessage;
            }
            // Handle regular messages
            if (typeof message.content === "string") {
                const role = message.role === "assistant" ? "assistant" : "user";
                return {
                    role,
                    content: message.content
                };
            }
            // Handle multi-modal content
            const role = message.role === "assistant" ? "assistant" : "user";
            return {
                role,
                content: message.content.map((content)=>{
                    if (content.type === "text") {
                        return {
                            type: "text",
                            text: content.text
                        };
                    }
                    return {
                        type: "image",
                        source: {
                            type: "base64",
                            media_type: `image/${content.image_url.url.substring("data:image/".length, content.image_url.url.indexOf(";base64"))}`,
                            data: content.image_url.url.substring(content.image_url.url.indexOf(",") + 1)
                        }
                    };
                })
            };
        });
        return this.mergeConsecutiveMessages(formattedMessages);
    }
    // Add helper method to prepare tools for API call
    prepareToolsForAPI(tools) {
        return tools.map((tool)=>{
            if (tool.metadata.parameters?.type !== "object") {
                throw new TypeError("Tool parameters must be an object");
            }
            return {
                input_schema: {
                    type: "object",
                    properties: tool.metadata.parameters.properties,
                    required: tool.metadata.parameters.required
                },
                name: tool.metadata.name,
                description: tool.metadata.description
            };
        });
    }
    mergeConsecutiveMessages(messages) {
        const result = [];
        for(let i = 0; i < messages.length; i++){
            if (i === 0) {
                result.push(messages[i]);
                continue;
            }
            const current = messages[i];
            const previous = result[result.length - 1];
            if (current.role === previous.role) {
                // Merge content based on type
                if (Array.isArray(previous.content)) {
                    if (Array.isArray(current.content)) {
                        previous.content.push(...current.content);
                    } else {
                        previous.content.push({
                            type: "text",
                            text: current.content
                        });
                    }
                } else {
                    if (Array.isArray(current.content)) {
                        previous.content = [
                            {
                                type: "text",
                                text: previous.content
                            },
                            ...current.content
                        ];
                    } else {
                        previous.content = `${previous.content}\n${current.content}`;
                    }
                }
            } else {
                result.push(current);
            }
        }
        return result;
    }
    async chat(params) {
        const { messages, stream, tools } = params;
        // Handle system messages
        let systemPrompt = null;
        const systemMessages = messages.filter((message)=>message.role === "system");
        if (systemMessages.length > 0) {
            systemPrompt = systemMessages.map((message)=>{
                const textContent = extractText(message.content);
                if (message.options && "cache_control" in message.options) {
                    return {
                        type: "text",
                        text: textContent,
                        cache_control: message.options.cache_control
                    };
                }
                return {
                    type: "text",
                    text: textContent
                };
            });
        }
        const beta = Array.isArray(systemPrompt) && systemPrompt.some((message)=>"cache_control" in message);
        let anthropic = this.session.anthropic;
        if (beta) {
            // @ts-expect-error type casting
            anthropic = anthropic.beta.promptCaching;
        }
        const apiParams = {
            model: this.getModelName(this.model),
            messages: this.mergeConsecutiveMessages(this.formatMessages(messages.filter((m)=>m.role !== "system"))),
            max_tokens: this.maxTokens ?? 4096,
            temperature: this.temperature,
            ...this.topP ? {
                top_p: this.topP
            } : {},
            ...systemPrompt && {
                system: systemPrompt
            },
            ...Object.assign({}, this.additionalChatOptions, params.additionalChatOptions)
        };
        if (tools?.length) {
            Object.assign(apiParams, {
                tools: this.prepareToolsForAPI(tools)
            });
        }
        if (stream) {
            return this.streamChat(anthropic, apiParams);
        }
        const response = await anthropic.messages.create(apiParams);
        const thinkingBlock = response.content.find((content)=>content.type === "thinking");
        const toolUseBlock = response.content.filter((content)=>content.type === "tool_use");
        const toolCall = toolUseBlock.length > 0 ? {
            toolCall: toolUseBlock.map((block)=>({
                    id: block.id,
                    name: block.name,
                    input: typeof block.input === "string" ? block.input : JSON.stringify(block.input)
                }))
        } : {};
        return {
            raw: response,
            message: {
                content: response.content.filter((content)=>content.type === "text" && content.text?.trim().length > 0).map((content)=>({
                        type: "text",
                        text: content.text
                    })),
                role: "assistant",
                options: {
                    ...toolCall,
                    thinking: thinkingBlock?.thinking,
                    thinking_signature: thinkingBlock?.signature
                }
            }
        };
    }
    async *streamChat(anthropic, params) {
        const stream = await anthropic.messages.create({
            ...params,
            stream: true
        });
        let currentToolCall = null;
        let accumulatedToolInput = "";
        for await (const part of stream){
            const textContent = part.type === "content_block_delta" && part.delta.type === "text_delta" ? part.delta.text : undefined;
            const thinking = part.type === "content_block_delta" && part.delta.type === "thinking_delta" ? part.delta.thinking : undefined;
            const thinkingSignature = part.type === "content_block_delta" && part.delta.type === "signature_delta" ? part.delta.signature : undefined;
            if (part.type === "content_block_start" && part.content_block.type === "tool_use") {
                currentToolCall = {
                    id: part.content_block.id,
                    name: part.content_block.name,
                    input: ""
                };
                accumulatedToolInput = "";
                continue;
            }
            if (part.type === "content_block_delta" && part.delta.type === "input_json_delta" && currentToolCall) {
                accumulatedToolInput += part.delta.partial_json;
                continue;
            }
            if (part.type === "content_block_stop" && currentToolCall) {
                yield {
                    raw: part,
                    delta: "",
                    options: {
                        toolCall: [
                            {
                                id: currentToolCall.id,
                                name: currentToolCall.name,
                                input: accumulatedToolInput
                            }
                        ]
                    }
                };
                currentToolCall = null;
                continue;
            }
            if (!textContent && !thinking && !thinkingSignature) continue;
            yield {
                raw: part,
                delta: textContent ?? "",
                options: {
                    thinking: thinking,
                    thinking_signature: thinkingSignature
                }
            };
        }
        return;
    }
    static toTool(tool) {
        if (tool.metadata.parameters?.type !== "object") {
            throw new TypeError("Tool parameters must be an object");
        }
        return {
            input_schema: {
                type: "object",
                properties: tool.metadata.parameters.properties,
                required: tool.metadata.parameters.required
            },
            name: tool.metadata.name,
            description: tool.metadata.description
        };
    }
}
/**
 * Convenience function to create a new Anthropic instance.
 * @param init - Optional initialization parameters for the Anthropic instance.
 * @returns A new Anthropic instance.
 */ const anthropic = (init)=>new Anthropic(init);

class AnthropicAgentWorker extends LLMAgentWorker {
}
class AnthropicAgent extends LLMAgent {
    constructor(params){
        const llm = params.llm ?? (Settings.llm instanceof Anthropic ? Settings.llm : new Anthropic());
        super({
            ...params,
            llm
        });
    }
    async chat(params) {
        const { stream } = params;
        if (stream) {
            // Anthropic does support this, but looks like it's not supported in the LITS LLM
            throw new Error("Anthropic does not support streaming");
        }
        return super.chat(params);
    }
}

export { ALL_AVAILABLE_ANTHROPIC_LEGACY_MODELS, ALL_AVAILABLE_ANTHROPIC_MODELS, ALL_AVAILABLE_V3_5_MODELS, ALL_AVAILABLE_V3_7_MODELS, ALL_AVAILABLE_V3_MODELS, Anthropic, AnthropicAgent, AnthropicAgentWorker, AnthropicSession, anthropic };
