Object.defineProperty(exports, '__esModule', { value: true });

var schema = require('@llamaindex/core/schema');
var env = require('@llamaindex/env');
var index_cjs = require('../../api/dist/index.cjs');

var U = /\{[^{}]+\}/g, S = ({ allowReserved: t, name: r, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${r}=${t ? e : encodeURIComponent(e)}`;
}, $ = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, k = (t)=>{
    switch(t){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, j = ({ allowReserved: t, explode: r, name: e, style: s, value: o })=>{
    if (!r) {
        let n = (t ? o : o.map((c)=>encodeURIComponent(c))).join(k(s));
        switch(s){
            case "label":
                return `.${n}`;
            case "matrix":
                return `;${e}=${n}`;
            case "simple":
                return n;
            default:
                return `${e}=${n}`;
        }
    }
    let a = $(s), i = o.map((n)=>s === "label" || s === "simple" ? t ? n : encodeURIComponent(n) : S({
            allowReserved: t,
            name: e,
            value: n
        })).join(a);
    return s === "label" || s === "matrix" ? a + i : i;
}, A = ({ allowReserved: t, explode: r, name: e, style: s, value: o })=>{
    if (o instanceof Date) return `${e}=${o.toISOString()}`;
    if (s !== "deepObject" && !r) {
        let n = [];
        Object.entries(o).forEach(([f, p])=>{
            n = [
                ...n,
                f,
                t ? p : encodeURIComponent(p)
            ];
        });
        let c = n.join(",");
        switch(s){
            case "form":
                return `${e}=${c}`;
            case "label":
                return `.${c}`;
            case "matrix":
                return `;${e}=${c}`;
            default:
                return c;
        }
    }
    let a = D(s), i = Object.entries(o).map(([n, c])=>S({
            allowReserved: t,
            name: s === "deepObject" ? `${e}[${n}]` : n,
            value: c
        })).join(a);
    return s === "label" || s === "matrix" ? a + i : i;
}, _ = ({ path: t, url: r })=>{
    let e = r, s = r.match(U);
    if (s) for (let o of s){
        let a = false, i = o.substring(1, o.length - 1), n = "simple";
        i.endsWith("*") && (a = true, i = i.substring(0, i.length - 1)), i.startsWith(".") ? (i = i.substring(1), n = "label") : i.startsWith(";") && (i = i.substring(1), n = "matrix");
        let c = t[i];
        if (c == null) continue;
        if (Array.isArray(c)) {
            e = e.replace(o, j({
                explode: a,
                name: i,
                style: n,
                value: c
            }));
            continue;
        }
        if (typeof c == "object") {
            e = e.replace(o, A({
                explode: a,
                name: i,
                style: n,
                value: c
            }));
            continue;
        }
        if (n === "matrix") {
            e = e.replace(o, `;${S({
                name: i,
                value: c
            })}`);
            continue;
        }
        let f = encodeURIComponent(n === "label" ? `.${c}` : c);
        e = e.replace(o, f);
    }
    return e;
}, C = ({ allowReserved: t, array: r, object: e } = {})=>(o)=>{
        let a = [];
        if (o && typeof o == "object") for(let i in o){
            let n = o[i];
            if (n != null) {
                if (Array.isArray(n)) {
                    a = [
                        ...a,
                        j({
                            allowReserved: t,
                            explode: true,
                            name: i,
                            style: "form",
                            value: n,
                            ...r
                        })
                    ];
                    continue;
                }
                if (typeof n == "object") {
                    a = [
                        ...a,
                        A({
                            allowReserved: t,
                            explode: true,
                            name: i,
                            style: "deepObject",
                            value: n,
                            ...e
                        })
                    ];
                    continue;
                }
                a = [
                    ...a,
                    S({
                        allowReserved: t,
                        name: i,
                        value: n
                    })
                ];
            }
        }
        return a.join("&");
    }, w = (t)=>{
    if (!t) return "stream";
    let r = t.split(";")[0]?.trim();
    if (r) {
        if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
        if (r === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((e)=>r.startsWith(e))) return "blob";
        if (r.startsWith("text/")) return "text";
    }
}, H = async (t, r)=>{
    let e = typeof r == "function" ? await r(t) : r;
    if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
}, P = async ({ security: t, ...r })=>{
    for (let e of t){
        let s = await H(e, r.auth);
        if (!s) continue;
        let o = e.name ?? "Authorization";
        switch(e.in){
            case "query":
                r.query || (r.query = {}), r.query[o] = s;
                break;
            case "header":
            default:
                r.headers.set(o, s);
                break;
        }
        return;
    }
}, b = (t)=>B({
        baseUrl: t.baseUrl ?? "",
        path: t.path,
        query: t.query,
        querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : C(t.querySerializer),
        url: t.url
    }), B = ({ baseUrl: t, path: r, query: e, querySerializer: s, url: o })=>{
    let a = o.startsWith("/") ? o : `/${o}`, i = t + a;
    r && (i = _({
        path: r,
        url: i
    }));
    let n = e ? s(e) : "";
    return n.startsWith("?") && (n = n.substring(1)), n && (i += `?${n}`), i;
}, R = (t, r)=>{
    let e = {
        ...t,
        ...r
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = O(t.headers, r.headers), e;
}, O = (...t)=>{
    let r = new Headers;
    for (let e of t){
        if (!e || typeof e != "object") continue;
        let s = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [o, a] of s)if (a === null) r.delete(o);
        else if (Array.isArray(a)) for (let i of a)r.append(o, i);
        else a !== undefined && r.set(o, typeof a == "object" ? JSON.stringify(a) : a);
    }
    return r;
}, y = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    exists(r) {
        return this._fns.indexOf(r) !== -1;
    }
    eject(r) {
        let e = this._fns.indexOf(r);
        e !== -1 && (this._fns = [
            ...this._fns.slice(0, e),
            ...this._fns.slice(e + 1)
        ]);
    }
    use(r) {
        this._fns = [
            ...this._fns,
            r
        ];
    }
}, E = ()=>({
        error: new y,
        request: new y,
        response: new y
    }), I = {
    bodySerializer: (t)=>JSON.stringify(t)
}, Q = C({
    allowReserved: false,
    array: {
        explode: true,
        style: "form"
    },
    object: {
        explode: true,
        style: "deepObject"
    }
}), V = {
    "Content-Type": "application/json"
}, q = (t = {})=>({
        ...I,
        baseUrl: "",
        headers: V,
        parseAs: "auto",
        querySerializer: Q,
        ...t
    });
var M = (t = {})=>{
    let r = R(q(), t), e = ()=>({
            ...r
        }), s = (i)=>(r = R(r, i), e()), o = E(), a = async (i)=>{
        let n = {
            ...r,
            ...i,
            fetch: i.fetch ?? r.fetch ?? globalThis.fetch,
            headers: O(r.headers, i.headers)
        };
        n.security && await P({
            ...n,
            security: n.security
        }), n.body && n.bodySerializer && (n.body = n.bodySerializer(n.body)), n.body || n.headers.delete("Content-Type");
        let c = b(n), f = {
            redirect: "follow",
            ...n
        }, p = new Request(c, f);
        for (let u of o.request._fns)p = await u(p, n);
        let T = n.fetch, l = await T(p);
        for (let u of o.response._fns)l = await u(l, p, n);
        let h = {
            request: p,
            response: l
        };
        if (l.ok) {
            if (l.status === 204 || l.headers.get("Content-Length") === "0") return {
                data: {},
                ...h
            };
            let u = (n.parseAs === "auto" ? w(l.headers.get("Content-Type")) : n.parseAs) ?? "json";
            if (u === "stream") return {
                data: l.body,
                ...h
            };
            let g = await l[u]();
            return u === "json" && (n.responseValidator && await n.responseValidator(g), n.responseTransformer && (g = await n.responseTransformer(g))), {
                data: g,
                ...h
            };
        }
        let m = await l.text();
        try {
            m = JSON.parse(m);
        } catch  {}
        let d = m;
        for (let u of o.error._fns)d = await u(m, l, p, n);
        if (d = d || {}, n.throwOnError) throw d;
        return {
            error: d,
            ...h
        };
    };
    return {
        buildUrl: b,
        connect: (i)=>a({
                ...i,
                method: "CONNECT"
            }),
        delete: (i)=>a({
                ...i,
                method: "DELETE"
            }),
        get: (i)=>a({
                ...i,
                method: "GET"
            }),
        getConfig: e,
        head: (i)=>a({
                ...i,
                method: "HEAD"
            }),
        interceptors: o,
        options: (i)=>a({
                ...i,
                method: "OPTIONS"
            }),
        patch: (i)=>a({
                ...i,
                method: "PATCH"
            }),
        post: (i)=>a({
                ...i,
                method: "POST"
            }),
        put: (i)=>a({
                ...i,
                method: "PUT"
            }),
        request: a,
        setConfig: s,
        trace: (i)=>a({
                ...i,
                method: "TRACE"
            })
    };
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var retry$2 = {};

var retry_operation;
var hasRequiredRetry_operation;

function requireRetry_operation () {
	if (hasRequiredRetry_operation) return retry_operation;
	hasRequiredRetry_operation = 1;
	function RetryOperation(timeouts, options) {
	    // Compatibility for the old (timeouts, retryForever) signature
	    if (typeof options === 'boolean') {
	        options = {
	            forever: options
	        };
	    }
	    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
	    this._timeouts = timeouts;
	    this._options = options || {};
	    this._maxRetryTime = options && options.maxRetryTime || Infinity;
	    this._fn = null;
	    this._errors = [];
	    this._attempts = 1;
	    this._operationTimeout = null;
	    this._operationTimeoutCb = null;
	    this._timeout = null;
	    this._operationStart = null;
	    this._timer = null;
	    if (this._options.forever) {
	        this._cachedTimeouts = this._timeouts.slice(0);
	    }
	}
	retry_operation = RetryOperation;
	RetryOperation.prototype.reset = function() {
	    this._attempts = 1;
	    this._timeouts = this._originalTimeouts.slice(0);
	};
	RetryOperation.prototype.stop = function() {
	    if (this._timeout) {
	        clearTimeout(this._timeout);
	    }
	    if (this._timer) {
	        clearTimeout(this._timer);
	    }
	    this._timeouts = [];
	    this._cachedTimeouts = null;
	};
	RetryOperation.prototype.retry = function(err) {
	    if (this._timeout) {
	        clearTimeout(this._timeout);
	    }
	    if (!err) {
	        return false;
	    }
	    var currentTime = new Date().getTime();
	    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
	        this._errors.push(err);
	        this._errors.unshift(new Error('RetryOperation timeout occurred'));
	        return false;
	    }
	    this._errors.push(err);
	    var timeout = this._timeouts.shift();
	    if (timeout === undefined) {
	        if (this._cachedTimeouts) {
	            // retry forever, only keep last error
	            this._errors.splice(0, this._errors.length - 1);
	            timeout = this._cachedTimeouts.slice(-1);
	        } else {
	            return false;
	        }
	    }
	    var self = this;
	    this._timer = setTimeout(function() {
	        self._attempts++;
	        if (self._operationTimeoutCb) {
	            self._timeout = setTimeout(function() {
	                self._operationTimeoutCb(self._attempts);
	            }, self._operationTimeout);
	            if (self._options.unref) {
	                self._timeout.unref();
	            }
	        }
	        self._fn(self._attempts);
	    }, timeout);
	    if (this._options.unref) {
	        this._timer.unref();
	    }
	    return true;
	};
	RetryOperation.prototype.attempt = function(fn, timeoutOps) {
	    this._fn = fn;
	    if (timeoutOps) {
	        if (timeoutOps.timeout) {
	            this._operationTimeout = timeoutOps.timeout;
	        }
	        if (timeoutOps.cb) {
	            this._operationTimeoutCb = timeoutOps.cb;
	        }
	    }
	    var self = this;
	    if (this._operationTimeoutCb) {
	        this._timeout = setTimeout(function() {
	            self._operationTimeoutCb();
	        }, self._operationTimeout);
	    }
	    this._operationStart = new Date().getTime();
	    this._fn(this._attempts);
	};
	RetryOperation.prototype.try = function(fn) {
	    console.log('Using RetryOperation.try() is deprecated');
	    this.attempt(fn);
	};
	RetryOperation.prototype.start = function(fn) {
	    console.log('Using RetryOperation.start() is deprecated');
	    this.attempt(fn);
	};
	RetryOperation.prototype.start = RetryOperation.prototype.try;
	RetryOperation.prototype.errors = function() {
	    return this._errors;
	};
	RetryOperation.prototype.attempts = function() {
	    return this._attempts;
	};
	RetryOperation.prototype.mainError = function() {
	    if (this._errors.length === 0) {
	        return null;
	    }
	    var counts = {};
	    var mainError = null;
	    var mainErrorCount = 0;
	    for(var i = 0; i < this._errors.length; i++){
	        var error = this._errors[i];
	        var message = error.message;
	        var count = (counts[message] || 0) + 1;
	        counts[message] = count;
	        if (count >= mainErrorCount) {
	            mainError = error;
	            mainErrorCount = count;
	        }
	    }
	    return mainError;
	};
	return retry_operation;
}

var hasRequiredRetry$1;

function requireRetry$1 () {
	if (hasRequiredRetry$1) return retry$2;
	hasRequiredRetry$1 = 1;
	(function (exports) {
		var RetryOperation = requireRetry_operation();
		exports.operation = function(options) {
		    var timeouts = exports.timeouts(options);
		    return new RetryOperation(timeouts, {
		        forever: options && (options.forever || options.retries === Infinity),
		        unref: options && options.unref,
		        maxRetryTime: options && options.maxRetryTime
		    });
		};
		exports.timeouts = function(options) {
		    if (options instanceof Array) {
		        return [].concat(options);
		    }
		    var opts = {
		        retries: 10,
		        factor: 2,
		        minTimeout: 1 * 1000,
		        maxTimeout: Infinity,
		        randomize: false
		    };
		    for(var key in options){
		        opts[key] = options[key];
		    }
		    if (opts.minTimeout > opts.maxTimeout) {
		        throw new Error('minTimeout is greater than maxTimeout');
		    }
		    var timeouts = [];
		    for(var i = 0; i < opts.retries; i++){
		        timeouts.push(this.createTimeout(i, opts));
		    }
		    if (options && options.forever && !timeouts.length) {
		        timeouts.push(this.createTimeout(i, opts));
		    }
		    // sort the array numerically ascending
		    timeouts.sort(function(a, b) {
		        return a - b;
		    });
		    return timeouts;
		};
		exports.createTimeout = function(attempt, opts) {
		    var random = opts.randomize ? Math.random() + 1 : 1;
		    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
		    timeout = Math.min(timeout, opts.maxTimeout);
		    return timeout;
		};
		exports.wrap = function(obj, options, methods) {
		    if (options instanceof Array) {
		        methods = options;
		        options = null;
		    }
		    if (!methods) {
		        methods = [];
		        for(var key in obj){
		            if (typeof obj[key] === 'function') {
		                methods.push(key);
		            }
		        }
		    }
		    for(var i = 0; i < methods.length; i++){
		        var method = methods[i];
		        var original = obj[method];
		        obj[method] = (function retryWrapper(original) {
		            var op = exports.operation(options);
		            var args = Array.prototype.slice.call(arguments, 1);
		            var callback = args.pop();
		            args.push(function(err) {
		                if (op.retry(err)) {
		                    return;
		                }
		                if (err) {
		                    arguments[0] = op.mainError();
		                }
		                callback.apply(this, arguments);
		            });
		            op.attempt(function() {
		                original.apply(obj, args);
		            });
		        }).bind(obj, original);
		        obj[method].options = options;
		    }
		}; 
	} (retry$2));
	return retry$2;
}

var retry$1;
var hasRequiredRetry;

function requireRetry () {
	if (hasRequiredRetry) return retry$1;
	hasRequiredRetry = 1;
	retry$1 = requireRetry$1();
	return retry$1;
}

var retryExports = requireRetry();
var retry = /*@__PURE__*/getDefaultExportFromCjs(retryExports);

const objectToString = Object.prototype.toString;
const isError = (value)=>objectToString.call(value) === '[object Error]';
const errorMessages = new Set([
    'network error',
    'Failed to fetch',
    'NetworkError when attempting to fetch resource.',
    'The Internet connection appears to be offline.',
    'Load failed',
    'Network request failed',
    'fetch failed',
    'terminated'
]);
function isNetworkError(error) {
    const isValid = error && isError(error) && error.name === 'TypeError' && typeof error.message === 'string';
    if (!isValid) {
        return false;
    }
    // We do an extra check for Safari 17+ as it has a very generic error message.
    // Network errors in Safari have no stack.
    if (error.message === 'Load failed') {
        return error.stack === undefined;
    }
    return errorMessages.has(error.message);
}

class AbortError extends Error {
    constructor(message){
        super();
        if (message instanceof Error) {
            this.originalError = message;
            ({ message } = message);
        } else {
            this.originalError = new Error(message);
            this.originalError.stack = this.stack;
        }
        this.name = 'AbortError';
        this.message = message;
    }
}
const decorateErrorWithCounts = (error, attemptNumber, options)=>{
    // Minus 1 from attemptNumber because the first attempt does not count as a retry
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
};
async function pRetry(input, options) {
    return new Promise((resolve, reject)=>{
        options = {
            ...options
        };
        options.onFailedAttempt ??= ()=>{};
        options.shouldRetry ??= ()=>true;
        options.retries ??= 10;
        const operation = retry.operation(options);
        const abortHandler = ()=>{
            operation.stop();
            reject(options.signal?.reason);
        };
        if (options.signal && !options.signal.aborted) {
            options.signal.addEventListener('abort', abortHandler, {
                once: true
            });
        }
        const cleanUp = ()=>{
            options.signal?.removeEventListener('abort', abortHandler);
            operation.stop();
        };
        operation.attempt(async (attemptNumber)=>{
            try {
                const result = await input(attemptNumber);
                cleanUp();
                resolve(result);
            } catch (error) {
                try {
                    if (!(error instanceof Error)) {
                        throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
                    }
                    if (error instanceof AbortError) {
                        throw error.originalError;
                    }
                    if (error instanceof TypeError && !isNetworkError(error)) {
                        throw error;
                    }
                    decorateErrorWithCounts(error, attemptNumber, options);
                    if (!await options.shouldRetry(error)) {
                        operation.stop();
                        reject(error);
                    }
                    await options.onFailedAttempt(error);
                    if (!operation.retry(error)) {
                        throw operation.mainError();
                    }
                } catch (finalError) {
                    decorateErrorWithCounts(finalError, attemptNumber, options);
                    cleanUp();
                    reject(finalError);
                }
            }
        });
    });
}

async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}

// Do not modify this variable or cause type errors
// eslint-disable-next-line no-var
var process;
/**
 * Represents a reader for parsing files using the LlamaParse API.
 * See https://github.com/run-llama/llama_parse
 */ class LlamaParseReader extends schema.FileReader {
    #client;
    constructor(params = {}){
        super(), // The base URL of the Llama Cloud Platform.
        this.baseUrl = "https://api.cloud.llamaindex.ai", // The result type for the parser.
        this.resultType = "text", // The interval in seconds to check if the parsing is done.
        this.checkInterval = 1, // The maximum timeout in seconds to wait for the parsing to finish.
        this.maxTimeout = 2000, // Whether to print the progress of the parsing.
        this.verbose = true, // The language to parse the file in.
        this.language = [
            "en"
        ], // New polling options:
        // Controls the backoff mode: "constant", "linear", or "exponential".
        this.backoffPattern = "linear", // Maximum interval in seconds between polls.
        this.maxCheckInterval = 5, // Maximum number of retryable errors before giving up.
        this.maxErrorCount = 4, // Deprecated. Use vendorMultimodal params. Whether to use gpt-4o to extract text.
        this.gpt4oMode = false, // Whether to ignore errors during parsing.
        this.ignoreErrors = true, // Whether to split by page using the pageSeparator (or "\n---\n" as default).
        this.splitByPage = true, // Whether to use the vendor multimodal API.
        this.useVendorMultimodalModel = false, this.output_tables_as_HTML = false;
        Object.assign(this, params);
        this.language = Array.isArray(this.language) ? this.language : [
            this.language
        ];
        this.stdout = params.stdout ?? "undefined" !== "undefined" ? process.stdout : undefined;
        const apiKey = params.apiKey ?? env.getEnv("LLAMA_CLOUD_API_KEY");
        if (!apiKey) {
            throw new Error("API Key is required for LlamaParseReader. Please pass the apiKey parameter or set the LLAMA_CLOUD_API_KEY environment variable.");
        }
        this.apiKey = apiKey;
        if (this.baseUrl.endsWith("/")) {
            this.baseUrl = this.baseUrl.slice(0, -1);
        }
        if (this.baseUrl.endsWith("/api/parsing")) {
            this.baseUrl = this.baseUrl.slice(0, -"/api/parsing".length);
        }
        if (params.gpt4oMode) {
            params.gpt4oApiKey = params.gpt4oApiKey ?? env.getEnv("LLAMA_CLOUD_GPT4O_API_KEY");
            this.gpt4oApiKey = params.gpt4oApiKey;
        }
        if (params.useVendorMultimodalModel) {
            params.vendorMultimodalApiKey = params.vendorMultimodalApiKey ?? env.getEnv("LLAMA_CLOUD_VENDOR_MULTIMODAL_API_KEY");
            this.vendorMultimodalApiKey = params.vendorMultimodalApiKey;
        }
        this.#client = M(q({
            headers: {
                Authorization: `Bearer ${this.apiKey}`
            },
            baseUrl: this.baseUrl
        }));
    }
    /**
   * Creates a job for the LlamaParse API.
   *
   * @param data - The file data as a Uint8Array.
   * @param filename - Optional filename for the file.
   * @returns A Promise resolving to the job ID as a string.
   */ async #createJob(data, filename) {
        if (this.verbose) {
            console.log("Started uploading the file");
        }
        let file = null;
        let input_s3_path = this.inputS3Path;
        let input_url = this.input_url;
        if (typeof data !== "string") {
            // TODO: remove Blob usage when we drop Node.js 18 support
            file = globalThis.File && filename ? new File([
                data
            ], filename) : new Blob([
                data
            ]);
        } else if (data.startsWith("s3://")) {
            input_s3_path = data;
        } else if (data.startsWith("http://") || data.startsWith("https://")) {
            input_url = data;
        }
        const body = {
            file,
            input_s3_path,
            input_url,
            language: this.language,
            parsing_instruction: this.parsingInstruction,
            skip_diagonal_text: this.skipDiagonalText,
            invalidate_cache: this.invalidateCache,
            do_not_cache: this.doNotCache,
            fast_mode: this.fastMode,
            do_not_unroll_columns: this.doNotUnrollColumns,
            page_separator: this.pageSeparator,
            page_prefix: this.pagePrefix,
            page_suffix: this.pageSuffix,
            gpt4o_mode: this.gpt4oMode,
            gpt4o_api_key: this.gpt4oApiKey,
            bounding_box: this.boundingBox,
            target_pages: this.targetPages,
            use_vendor_multimodal_model: this.useVendorMultimodalModel,
            vendor_multimodal_model_name: this.vendorMultimodalModelName,
            vendor_multimodal_api_key: this.vendorMultimodalApiKey,
            premium_mode: this.premiumMode,
            webhook_url: this.webhookUrl,
            take_screenshot: this.takeScreenshot,
            disable_ocr: this.disableOcr,
            disable_reconstruction: this.disableReconstruction,
            output_s3_path_prefix: this.outputS3PathPrefix,
            continuous_mode: this.continuousMode,
            is_formatting_instruction: this.isFormattingInstruction,
            annotate_links: this.annotateLinks,
            azure_openai_deployment_name: this.azureOpenaiDeploymentName,
            azure_openai_endpoint: this.azureOpenaiEndpoint,
            azure_openai_api_version: this.azureOpenaiApiVersion,
            azure_openai_key: this.azureOpenaiKey,
            auto_mode: this.auto_mode,
            auto_mode_trigger_on_image_in_page: this.auto_mode_trigger_on_image_in_page,
            auto_mode_trigger_on_table_in_page: this.auto_mode_trigger_on_table_in_page,
            auto_mode_trigger_on_text_in_page: this.auto_mode_trigger_on_text_in_page,
            auto_mode_trigger_on_regexp_in_page: this.auto_mode_trigger_on_regexp_in_page,
            bbox_bottom: this.bbox_bottom,
            bbox_left: this.bbox_left,
            bbox_right: this.bbox_right,
            bbox_top: this.bbox_top,
            disable_image_extraction: this.disable_image_extraction,
            extract_charts: this.extract_charts,
            guess_xlsx_sheet_name: this.guess_xlsx_sheet_name,
            html_make_all_elements_visible: this.html_make_all_elements_visible,
            html_remove_fixed_elements: this.html_remove_fixed_elements,
            html_remove_navigation_elements: this.html_remove_navigation_elements,
            http_proxy: this.http_proxy,
            max_pages: this.max_pages,
            output_pdf_of_document: this.output_pdf_of_document,
            structured_output: this.structured_output,
            structured_output_json_schema: this.structured_output_json_schema,
            structured_output_json_schema_name: this.structured_output_json_schema_name,
            extract_layout: this.extract_layout,
            output_tables_as_HTML: this.output_tables_as_HTML,
            input_s3_region: this.input_s3_region,
            output_s3_region: this.output_s3_region,
            preserve_layout_alignment_across_pages: this.preserve_layout_alignment_across_pages,
            spreadsheet_extract_sub_tables: this.spreadsheet_extract_sub_tables,
            formatting_instruction: this.formatting_instruction,
            parse_mode: this.parse_mode,
            system_prompt: this.system_prompt,
            system_prompt_append: this.system_prompt_append,
            user_prompt: this.user_prompt,
            job_timeout_in_seconds: this.job_timeout_in_seconds,
            job_timeout_extra_time_per_page_in_seconds: this.job_timeout_extra_time_per_page_in_seconds,
            strict_mode_image_extraction: this.strict_mode_image_extraction,
            strict_mode_image_ocr: this.strict_mode_image_ocr,
            strict_mode_reconstruction: this.strict_mode_reconstruction,
            strict_mode_buggy_font: this.strict_mode_buggy_font,
            ignore_document_elements_for_layout_detection: this.ignore_document_elements_for_layout_detection,
            complemental_formatting_instruction: this.complemental_formatting_instruction,
            content_guideline_instruction: this.content_guideline_instruction,
            adaptive_long_table: this.adaptive_long_table,
            model: this.model
        };
        const response = await index_cjs.uploadFileApiV1ParsingUploadPost({
            client: this.#client,
            throwOnError: true,
            query: {
                project_id: this.project_id ?? null,
                organization_id: this.organization_id ?? null
            },
            signal: AbortSignal.timeout(this.maxTimeout * 1000),
            body
        });
        return response.data.id;
    }
    /**
   * Retrieves the result of a parsing job.
   *
   * Uses a polling loop with retry logic. Each API call is retried
   * up to maxErrorCount times if it fails with a 5XX or socket error.
   * The delay between polls increases according to the specified backoffPattern ("constant", "linear", or "exponential"),
   * capped by maxCheckInterval.
   *
   * @param jobId - The job ID.
   * @param resultType - The type of result to fetch ("text", "json", or "markdown").
   * @returns A Promise resolving to the job result.
   */ async getJobResult(jobId, resultType) {
        let tries = 0;
        let currentInterval = this.checkInterval;
        while(true){
            await sleep(currentInterval * 1000);
            // Wraps the API call in a retry
            let result;
            try {
                result = await pRetry(()=>index_cjs.getJobApiV1ParsingJobJobIdGet({
                        client: this.#client,
                        throwOnError: true,
                        path: {
                            job_id: jobId
                        },
                        query: {
                            project_id: this.project_id ?? null,
                            organization_id: this.organization_id ?? null
                        },
                        signal: AbortSignal.timeout(this.maxTimeout * 1000)
                    }), {
                    retries: this.maxErrorCount,
                    onFailedAttempt: (error)=>{
                        // Retry only on 5XX or socket errors.
                        const status = error.cause?.response?.status;
                        if (!(status && status >= 500 && status < 600 || error.cause?.code && (error.cause.code === "ECONNRESET" || error.cause.code === "ETIMEDOUT" || error.cause.code === "ECONNREFUSED"))) {
                            throw error;
                        }
                        if (this.verbose) {
                            console.warn(`Attempting to get job ${jobId} result (attempt ${error.attemptNumber}) failed. Retrying...`);
                        }
                    }
                });
            } catch (e) {
                throw new Error(`Max error count reached for job ${jobId}: ${e.message}`);
            }
            const { data } = result;
            const status = data["status"];
            if (status === "SUCCESS") {
                let resultData;
                switch(resultType){
                    case "json":
                        {
                            resultData = await index_cjs.getJobJsonResultApiV1ParsingJobJobIdResultJsonGet({
                                client: this.#client,
                                throwOnError: true,
                                path: {
                                    job_id: jobId
                                },
                                query: {
                                    project_id: this.project_id ?? null,
                                    organization_id: this.organization_id ?? null
                                },
                                signal: AbortSignal.timeout(this.maxTimeout * 1000)
                            });
                            break;
                        }
                    case "markdown":
                        {
                            resultData = await index_cjs.getJobResultApiV1ParsingJobJobIdResultMarkdownGet({
                                client: this.#client,
                                throwOnError: true,
                                path: {
                                    job_id: jobId
                                },
                                query: {
                                    project_id: this.project_id ?? null,
                                    organization_id: this.organization_id ?? null
                                },
                                signal: AbortSignal.timeout(this.maxTimeout * 1000)
                            });
                            break;
                        }
                    case "text":
                        {
                            resultData = await index_cjs.getJobTextResultApiV1ParsingJobJobIdResultTextGet({
                                client: this.#client,
                                throwOnError: true,
                                path: {
                                    job_id: jobId
                                },
                                query: {
                                    project_id: this.project_id ?? null,
                                    organization_id: this.organization_id ?? null
                                },
                                signal: AbortSignal.timeout(this.maxTimeout * 1000)
                            });
                            break;
                        }
                }
                return resultData.data;
            } else if (status === "PENDING") {
                if (this.verbose && tries % 10 === 0) {
                    this.stdout?.write(".");
                }
                tries++;
            } else {
                if (this.verbose) {
                    console.error(`Received error response ${status} for job ${jobId}. Got Error Code: ${data.error_code} and Error Message: ${data.error_message}`);
                }
                throw new Error(`Failed to parse the file: ${jobId}, status: ${status}`);
            }
            // Adjust the polling interval based on the backoff pattern.
            if (this.backoffPattern === "exponential") {
                currentInterval = Math.min(currentInterval * 2, this.maxCheckInterval);
            } else if (this.backoffPattern === "linear") {
                currentInterval = Math.min(currentInterval + this.checkInterval, this.maxCheckInterval);
            } else if (this.backoffPattern === "constant") {
                currentInterval = this.checkInterval;
            }
        }
    }
    async loadData(filePath) {
        if (!filePath) {
            if (this.input_url) {
                return this.loadDataAsContent(this.input_url, this.input_url);
            } else if (this.inputS3Path) {
                return this.loadDataAsContent(this.inputS3Path, this.inputS3Path);
            } else {
                throw new TypeError("File path is required");
            }
        } else {
            const data = filePath.startsWith("s3://") || filePath.startsWith("http://") || filePath.startsWith("https://") ? filePath : await env.fs.readFile(filePath);
            return this.loadDataAsContent(data, filePath);
        }
    }
    /**
   * Loads data from a file and returns an array of Document objects.
   * To be used with resultType "text" or "markdown".
   *
   * @param fileContent - The content of the file as a Uint8Array.
   * @param filename - Optional filename for the file.
   * @returns A Promise that resolves to an array of Document objects.
   */ async loadDataAsContent(fileContent, filename) {
        return this.#createJob(fileContent, filename).then(async (jobId)=>{
            if (this.verbose) {
                console.log(`Started parsing the file under job id ${jobId}`);
            }
            // Return results as Document objects.
            const jobResults = await this.getJobResult(jobId, this.resultType);
            const resultText = jobResults[this.resultType];
            // Split the text by separator if splitByPage is true.
            if (this.splitByPage) {
                return this.splitTextBySeparator(resultText);
            }
            return [
                new schema.Document({
                    text: resultText
                })
            ];
        }).catch((error)=>{
            console.warn(`Error while parsing the file with: ${error.message ?? error.detail}`);
            if (this.ignoreErrors) {
                return [];
            } else {
                throw error;
            }
        });
    }
    /**
   * Loads data from a file and returns an array of JSON objects.
   * To be used with resultType "json".
   *
   * @param filePathOrContent - The file path or the file content as a Uint8Array.
   * @returns A Promise that resolves to an array of JSON objects.
   */ async loadJson(filePathOrContent) {
        let jobId;
        const isFilePath = typeof filePathOrContent === "string";
        try {
            const data = isFilePath ? await env.fs.readFile(filePathOrContent) : filePathOrContent;
            // Create a job for the file.
            jobId = await this.#createJob(data, isFilePath ? env.path.basename(filePathOrContent) : undefined);
            if (this.verbose) {
                console.log(`Started parsing the file under job id ${jobId}`);
            }
            // Return results as an array of JSON objects.
            const resultJson = await this.getJobResult(jobId, "json");
            resultJson.job_id = jobId;
            resultJson.file_path = isFilePath ? filePathOrContent : undefined;
            return [
                resultJson
            ];
        } catch (e) {
            console.error(`Error while parsing the file under job id ${jobId}`, e);
            if (this.ignoreErrors) {
                return [];
            } else {
                throw e;
            }
        }
    }
    /**
   * Downloads and saves images from a given JSON result to a specified download path.
   * Currently only supports resultType "json".
   *
   * @param jsonResult - The JSON result containing image information.
   * @param downloadPath - The path where the downloaded images will be saved.
   * @returns A Promise that resolves to an array of image objects.
   */ async getImages(jsonResult, downloadPath) {
        try {
            // Create download directory if it doesn't exist (checks for write access).
            try {
                await env.fs.access(downloadPath);
            } catch  {
                await env.fs.mkdir(downloadPath, {
                    recursive: true
                });
            }
            const images = [];
            for (const result of jsonResult){
                const jobId = result.job_id;
                for (const page of result.pages){
                    if (this.verbose) {
                        console.log(`> Image for page ${page.page}: ${page.images}`);
                    }
                    for (const image of page.images){
                        const imageName = image.name;
                        const imagePath = await this.getImagePath(downloadPath, jobId, imageName);
                        await this.fetchAndSaveImage(imageName, imagePath, jobId);
                        // Assign metadata to the image.
                        image.path = imagePath;
                        image.job_id = jobId;
                        image.original_pdf_path = result.file_path;
                        image.page_number = page.page;
                        images.push(image);
                    }
                }
            }
            return images;
        } catch (e) {
            console.error(`Error while downloading images from the parsed result`, e);
            if (this.ignoreErrors) {
                return [];
            } else {
                throw e;
            }
        }
    }
    /**
   * Constructs the file path for an image.
   *
   * @param downloadPath - The base download directory.
   * @param jobId - The job ID.
   * @param imageName - The image name.
   * @returns A Promise that resolves to the full image path.
   */ async getImagePath(downloadPath, jobId, imageName) {
        return env.path.join(downloadPath, `${jobId}-${imageName}`);
    }
    /**
   * Fetches an image from the API and saves it to the specified path.
   *
   * @param imageName - The name of the image.
   * @param imagePath - The local path to save the image.
   * @param jobId - The associated job ID.
   */ async fetchAndSaveImage(imageName, imagePath, jobId) {
        const response = await index_cjs.getJobImageResultApiV1ParsingJobJobIdResultImageNameGet({
            client: this.#client,
            path: {
                job_id: jobId,
                name: imageName
            },
            query: {
                project_id: this.project_id ?? null,
                organization_id: this.organization_id ?? null
            }
        });
        if (response.error) {
            throw new Error(`Failed to download image: ${response.error.detail}`);
        }
        const blob = await response.data;
        // Write the image buffer to the specified imagePath.
        await env.fs.writeFile(imagePath, new Uint8Array(await blob.arrayBuffer()));
    }
    /**
   * Filters out invalid values (null, undefined, empty string) for specific parameters.
   *
   * @param params - The parameters object.
   * @param keysToCheck - The keys to check for valid values.
   * @returns A new object with filtered parameters.
   */ filterSpecificParams(params, keysToCheck) {
        const filteredParams = {};
        for (const [key, value] of Object.entries(params)){
            if (keysToCheck.includes(key)) {
                if (value !== null && value !== undefined && value !== "") {
                    filteredParams[key] = value;
                }
            } else {
                filteredParams[key] = value;
            }
        }
        return filteredParams;
    }
    /**
   * Splits text into Document objects using the page separator.
   *
   * @param text - The text to be split.
   * @returns An array of Document objects.
   */ splitTextBySeparator(text) {
        const separator = this.pageSeparator ?? "\n---\n";
        const textChunks = text.split(separator);
        return textChunks.map((docChunk)=>new schema.Document({
                text: docChunk
            }));
    }
}

exports.LlamaParseReader = LlamaParseReader;
